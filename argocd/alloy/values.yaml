alloy:
  configMap:
    content: |
      // Loki write endpoint for logs
      loki.write "default" {
        endpoint {
          url = "http://loki-gateway.loki/loki/api/v1/push"
          headers = {
            "X-Scope-OrgID" = "fake",
          }
        }
      }

      // Prometheus remote write endpoint for metrics
      prometheus.remote_write "default" {
        endpoint {
          url = "https://mimir.str08.net/api/v1/push"
          headers = {
            "X-Scope-OrgID" = "anonymous",
          }
        }
        
        external_labels = {
          cluster = "kkg",
        }
      }

      // Mimir rules endpoint for PrometheusRule resources
      mimir.rules.kubernetes "default" {
        address = "https://mimir.str08.net"
        tenant_id = "anonymous"
        
        // Select all PrometheusRule resources (empty selector)
        rule_selector {
          match_labels = {}  // Monitor all PrometheusRule resources
        }
        
        // Select namespaces where PrometheusRule resources are monitored
        rule_namespace_selector {
          match_labels = {}  // Monitor all namespaces
        }
      }

      // Kubernetes discovery for services
      discovery.kubernetes "services" {
        role = "service"
      }

      // Kubernetes discovery for pods
      discovery.kubernetes "pods" {
        role = "pod"
      }

      // Kubernetes discovery for nodes
      discovery.kubernetes "nodes" {
        role = "node"
      }

      // Kubernetes discovery for PodMonitors
      discovery.kubernetes "podmonitors" {
        role = "podmonitor"
      }

      // Kubernetes discovery for ServiceMonitors
      discovery.kubernetes "servicemonitors" {
        role = "servicemonitor"
      }

      // Kubernetes discovery for API server endpoints
      discovery.kubernetes "api_endpoints" {
        role = "endpoints"
      }

      // Filter API server endpoints down to the default/kubernetes service
      discovery.relabel "kubernetes_api" {
        targets = discovery.kubernetes.api_endpoints.targets

        rule {
          action = "keep"
          source_labels = ["__meta_kubernetes_service_name", "__meta_kubernetes_namespace"]
          separator = ";"
          regex = "kubernetes;default"
        }

        rule {
          action = "keep"
          source_labels = ["__meta_kubernetes_endpoint_port_name"]
          regex = "https"
        }
      }

      // Normalize kubelet discovery targets to use the secured port
      discovery.relabel "kubelet_targets" {
        targets = discovery.kubernetes.nodes.targets

        rule {
          action = "replace"
          source_labels = ["__meta_kubernetes_node_address_InternalIP"]
          target_label = "__address__"
          regex = "(.+)"
          replacement = "$1:10250"
        }

        rule {
          action = "replace"
          source_labels = ["__meta_kubernetes_node_name"]
          target_label = "instance"
        }
      }

      // Scrape Kubernetes API server metrics
      prometheus.scrape "kubernetes_api" {
        targets = discovery.relabel.kubernetes_api.output
        forward_to = [prometheus.remote_write.default.receiver]
        
        scrape_interval = "30s"
        metrics_path = "/metrics"
        
        clustering {
          enabled = true
        }
      }

      // Scrape node metrics (kubelet)
      prometheus.scrape "kubernetes_nodes" {
        targets = discovery.relabel.kubelet_targets.output
        forward_to = [prometheus.remote_write.default.receiver]
        
        scrape_interval = "30s"
        metrics_path = "/metrics"
        scheme = "https"
        bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        tls_config {
          ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
          insecure_skip_verify = true
        }
        
        clustering {
          enabled = false  // Disable clustering for node metrics to avoid duplicates
        }
      }

      // Scrape cAdvisor metrics
      prometheus.scrape "kubernetes_cadvisor" {
        targets = discovery.relabel.kubelet_targets.output
        forward_to = [prometheus.remote_write.default.receiver]
        
        scrape_interval = "30s"
        metrics_path = "/metrics/cadvisor"
        scheme = "https"
        bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        tls_config {
          ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
          insecure_skip_verify = true
        }
        
        clustering {
          enabled = false  // Disable clustering for cAdvisor to avoid duplicates
        }
      }

      // Process PodMonitors
      prometheus.operator.podmonitors "podmonitors" {
        forward_to = [prometheus.remote_write.default.receiver]
        
        clustering {
          enabled = true
        }
      }

      // Process ServiceMonitors
      prometheus.operator.servicemonitors "servicemonitors" {
        forward_to = [prometheus.remote_write.default.receiver]
        
        clustering {
          enabled = true
        }
      }

      // Relabel pod discovery targets to add proper labels
      discovery.relabel "pod_logs" {
        targets = discovery.kubernetes.pods.targets

        // Label creation - "namespace" field from "__meta_kubernetes_namespace"
        rule {
          source_labels = ["__meta_kubernetes_namespace"]
          action = "replace"
          target_label = "namespace"
        }

        // Label creation - "pod" field from "__meta_kubernetes_pod_name"
        rule {
          source_labels = ["__meta_kubernetes_pod_name"]
          action = "replace"
          target_label = "pod"
        }

        // Label creation - "container" field from "__meta_kubernetes_pod_container_name"
        rule {
          source_labels = ["__meta_kubernetes_pod_container_name"]
          action = "replace"
          target_label = "container"
        }

        // Label creation - "app" field from "__meta_kubernetes_pod_label_app_kubernetes_io_name"
        rule {
          source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
          action = "replace"
          target_label = "app"
        }

        // Label creation - "container_runtime" field from "__meta_kubernetes_pod_container_id"
        rule {
          source_labels = ["__meta_kubernetes_pod_container_id"]
          action = "replace"
          target_label = "container_runtime"
          regex = "^(\\S+):\\/\\/.+$"
          replacement = "$1"
        }

        // Label creation - "job" field from namespace and pod name
        rule {
          source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_name"]
          action = "replace"
          target_label = "job"
          separator = ";"
          regex = "([^;]+);([^;]+)"
          replacement = "$1/$2"
        }

        // Default pod log path resolution
        rule {
          source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_name", "__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
          action = "replace"
          target_label = "__path__"
          separator = ";"
          regex = "([^;]+);([^;]+);([^;]+);([^;]+)"
          replacement = "/var/log/pods/$1_$2_$3/$4/*.log"
        }

        // Override log path for containerd runtimes
        rule {
          source_labels = ["container_runtime", "__meta_kubernetes_namespace", "__meta_kubernetes_pod_name", "__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
          action = "replace"
          target_label = "__path__"
          separator = ";"
          regex = "containerd;([^;]+);([^;]+);([^;]+);([^;]+)"
          replacement = "/var/log/pods/$1_$2_$3/$4/*.log"
        }

        // Override log path for CRI-O runtimes
        rule {
          source_labels = ["container_runtime", "__meta_kubernetes_namespace", "__meta_kubernetes_pod_name", "__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
          action = "replace"
          target_label = "__path__"
          separator = ";"
          regex = "cri-o;([^;]+);([^;]+);([^;]+);([^;]+)"
          replacement = "/var/log/pods/$1_$2_$3/$4/*.log"
        }
      }

      // Collect pod logs with automatic Kubernetes labels
      loki.source.kubernetes "pod_logs" {
        targets    = discovery.relabel.pod_logs.output
        forward_to = [loki.process.pod_logs.receiver]
        
        clustering {
          enabled = true
        }
      }

      // Process logs and add cluster label
      loki.process "pod_logs" {
        stage.static_labels {
          values = {
            cluster = "kkg",
          }
        }

        forward_to = [loki.write.default.receiver]
      }

      // Scrape Alloy's own metrics
      prometheus.scrape "alloy_metrics" {
        targets = [{"__address__" = "localhost:12345"}]
        forward_to = [prometheus.remote_write.default.receiver]
        scrape_interval = "15s"
        metrics_path = "/metrics"
        
        clustering {
          enabled = false  // Don't cluster self-monitoring
        }
      }

controller:
  type: 'deployment'

serviceMonitor:
  enabled: true

rbac:
  create: true

serviceAccount:
  create: true
  name: alloy

# Additional RBAC rules for PrometheusRule access and pod logs
extraObjects:
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: alloy-prometheusrule-reader
    rules:
    - apiGroups: [""]
      resources: ["namespaces", "nodes", "pods", "pods/log", "services", "endpoints", "secrets"]
      verbs: ["get", "list", "watch"]
    - apiGroups: ["discovery.k8s.io"]
      resources: ["endpointslices"]
      verbs: ["get", "list", "watch"]
    - apiGroups: ["monitoring.coreos.com"]
      resources: ["prometheusrules", "podmonitors", "servicemonitors", "probes"]
      verbs: ["get", "list", "watch"]
  - apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: alloy-prometheusrule-reader
    subjects:
    - kind: ServiceAccount
      name: alloy
      namespace: alloy
    roleRef:
      kind: ClusterRole
      name: alloy-prometheusrule-reader
      apiGroup: rbac.authorization.k8s.io

ingress:
  enabled: true
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt
  ingressClassName: traefik
  hosts:
    - alloy.str08.net
  tls:
    - hosts:
        - alloy.str08.net
      secretName: alloy.str08.net-dns01
